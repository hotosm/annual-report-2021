<!DOCTYPE html>
<html>
<head>

    <meta name='robots' content='index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1' />
	  <link rel="alternate" hreflang="en" href="" />
	  <link rel="icon" type="image/x-icon" href="">

	  <meta name="twitter:card" content="summary_large_image" />
	  <meta name="twitter:title" content="2022 Annual Report | HOTOSM" />
	  <meta name="twitter:description" content="Mapping, for everyone." />
	  <meta name="twitter:site" content="@hotosm" />
	  <meta name="twitter:image" content="" />
	  <meta property="og:locale" content="en_US" />
		<meta property="og:type" content="article" />
		<meta property="og:title" content="2022 Annual Report | HOTOSM" />
		<meta property="og:description" content="Mapping, for everyone." />
		<meta property="og:url" content="" />
		<meta property="og:site_name" content="HOTOSM.org" />
		<meta property="article:publisher" content="https://www.facebook.com/hotosm" />
		<meta property="og:image" content="" />
		<meta property="og:image:width" content="2560" />

    <meta charset='utf-8' />
    <title>2022 Annual Report | HOTOSM</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <meta name="author" content="Carbon Cure">
    <meta property="article:published_time" content="2022-01-24T07:00:00+00:00" />
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.8.2/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.8.2/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2-globe.beta/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2-globe.beta/mapbox-gl.js"></script>
    <script src="https://unpkg.com/intersection-observer@0.12.0/intersection-observer.js"></script>
    <script src="https://unpkg.com/scrollama"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Archivo:wght@100;400;700&family=Open+Sans:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap" rel="stylesheet">
    <link href="css/style.css" rel="stylesheet" />
    <script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>

    <!-- GA CODE NEEDED -->

    <script>
    // When the user scrolls the page, execute myFunction
      window.onscroll = function() {myFunction()};

      function myFunction() {
        var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
        var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        var scrolled = (winScroll / height) * 100;
        document.getElementById("myBar").style.width = scrolled + "%";
      }
    </script>

</head>
<body>

  <div class="progress-container">
    <div class="progress-bar" id="myBar"></div>
</div>

  <div id="map"></div>

  <div id='chapter4legend' class='legend'>
	<h4>CarbonCure's Footprint</h4>
	<ul class='legend-ul'>
		<li><div><span style='background-color: #101820'></span>Concrete plants </div></li>
	</ul>
	<h5><strong>Data</strong>: Carbon Cure OSM, <a href='https://www.openstreetmap.org' target='_blank'>OSM</a></h5>
	</div>

  <div id="mapInset"></div>
  <div id="story"></div>

  <script src="./config.js"></script>
  <script>
  var initLoad = true;
  var layerTypes = {
      'fill': ['fill-opacity'],
      'line': ['line-opacity'],
      'circle': ['circle-opacity', 'circle-stroke-opacity'],
      'symbol': ['icon-opacity', 'text-opacity'],
      'raster': ['raster-opacity'],
      'fill-extrusion': ['fill-extrusion-opacity'],
      'heatmap': ['heatmap-opacity']
  }

  var alignments = {
      'left': 'lefty',
      'center': 'centered',
      'right': 'righty',
      'full': 'fully'
  }

  function getLayerPaintType(layer) {
      var layerType = map.getLayer(layer).type;
      return layerTypes[layerType];
  }

  function setLayerOpacity(layer) {
      var paintProps = getLayerPaintType(layer.layer);
      paintProps.forEach(function(prop) {
          var options = {};
          if (layer.duration) {
              var transitionProp = prop + "-transition";
              options = { "duration": layer.duration };
              map.setPaintProperty(layer.layer, transitionProp, options);
          }
          map.setPaintProperty(layer.layer, prop, layer.opacity, options);
      });
  }

  var story = document.getElementById('story');
  var features = document.createElement('div');
  features.setAttribute('id', 'features');

  var header = document.createElement('div');

  if (config.title) {
  		var titleText = document.createElement('div');
  		titleText.innerHTML = config.title;
  		header.appendChild(titleText);
  }

  if (config.subtitle) {
      var subtitleText = document.createElement('h2');
      subtitleText.innerText = config.subtitle;
      header.appendChild(subtitleText);
  }

  if (config.byline) {
      var bylineText = document.createElement('p');
      bylineText.innerText = config.byline;
      header.appendChild(bylineText);
  }

  if (header.innerText.length > 0) {
      header.classList.add(config.theme);
      header.setAttribute('id', 'header');
      story.appendChild(header);
  }

  config.chapters.forEach((record, idx) => {
      var container = document.createElement('div');
      var chapter = document.createElement('div');

      if (record.title) {
          var title = document.createElement('h3');
          title.innerText = record.title;
          chapter.appendChild(title);
      }

      if (record.image) {
          var image = new Image();
          image.src = record.image;
          chapter.appendChild(image);
      }

      if (record.description) {
          var story = document.createElement('p');
          story.innerHTML = record.description;
          chapter.appendChild(story);
      }

      container.setAttribute('id', record.id);
      container.classList.add('step');
      if (idx === 0) {
          container.classList.add('active');
      }

      chapter.classList.add(config.theme);
      container.appendChild(chapter);
      container.classList.add(alignments[record.alignment] || 'centered');
      if (record.hidden) {
          container.classList.add('hidden');
      }
      features.appendChild(container);
  });

  story.appendChild(features);

  var footer = document.createElement('div');

  if (config.footer) {
      var footerText = document.createElement('p');
      footerText.innerHTML = config.footer;
      footer.appendChild(footerText);
  }

  if (footer.innerText.length > 0) {
      footer.classList.add(config.theme);
      footer.setAttribute('id', 'footer');
      story.appendChild(footer);
  }

  mapboxgl.accessToken = config.accessToken;

  const transformRequest = (url) => {
      const hasQuery = url.indexOf("?") !== -1;
      const suffix = hasQuery ? "&pluginName=scrollytellingV2" : "?pluginName=scrollytellingV2";
      return {
        url: url + suffix
      }
  }

  var map = new mapboxgl.Map({
      container: 'map',
      style: config.style,
      center: config.chapters[0].location.center,
      zoom: config.chapters[0].location.zoom,
      bearing: config.chapters[0].location.bearing,
      pitch: config.chapters[0].location.pitch,
      interactive: false,
      transformRequest: transformRequest,
      projection: config.projection
  });

  // Create a inset map if enabled in config.js
  if (config.inset) {
   var insetMap = new mapboxgl.Map({
      container: 'mapInset', // container id
      style: 'mapbox://styles/mapbox/dark-v10', //hosted style id
      center: config.chapters[0].location.center,
      // Hardcode above center value if you want insetMap to be static.
      zoom: 3, // starting zoom
      hash: false,
      interactive: false,
      projection: 'globe',
      attributionControl: false
    });
  }

  if (config.showMarkers) {
      var marker = new mapboxgl.Marker({ color: config.markerColor });
      marker.setLngLat(config.chapters[0].location.center).addTo(map);
  }

  // instantiate the scrollama
  var scroller = scrollama();


  map.on("load", function() {
      if (config.use3dTerrain) {
          map.addSource('mapbox-dem', {
              'type': 'raster-dem',
              'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
              'tileSize': 512,
              'maxzoom': 14
          });
          // add the DEM source as a terrain layer with exaggerated height
          map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });

          // add a sky layer that will show when the map is highly pitched
          map.addLayer({
              'id': 'sky',
              'type': 'sky',
              'paint': {
                  'sky-type': 'atmosphere',
                  'sky-atmosphere-sun': [0.0, 0.0],
                  'sky-atmosphere-sun-intensity': 5
              }
          });
      };

      map.setFog({
        'horizon-blend': 0.1,
        'star-intensity': 0.15,
        'color': '#4a6993',
        'high-color': 'rgba(36, 51, 71, 5)',
        'space-color': 'rgba(16, 24, 32, 1.0)'
      });

      // As the map moves, grab and update bounds in inset map.
      if (config.inset) {
      map.on('move', getInsetBounds);
      }
      // setup the instance, pass callback functions
      scroller
      .setup({
          step: '.step',
          offset: 0.5,
          progress: true
      })

      .onStepEnter(async response => {
          var chapter = config.chapters.find(chap => chap.id === response.element.id);
          var chapterid = chapter.id;

          if (chapterid == "chapter-4") {
               $("#chapter4legend").show("slow");
          } else
               $("#chapter4legend").hide("fast");


          response.element.classList.add('active');
          map[chapter.mapAnimation || 'flyTo'](chapter.location);
          // Incase you do not want to have a dynamic inset map,
          // rather want to keep it a static view but still change the
          // bbox as main map move: comment out the below if section.
          if (config.inset) {
            if (chapter.location.zoom < 5) {
              insetMap.flyTo({center: chapter.location.center, zoom: 0});
            }
            else {
              insetMap.flyTo({center: chapter.location.center, zoom: 3});
            }
          }
          if (config.showMarkers) {
              marker.setLngLat(chapter.location.center);
          }
          if (chapter.onChapterEnter.length > 0) {
              chapter.onChapterEnter.forEach(setLayerOpacity);
          }
          if (chapter.callback) {
              window[chapter.callback]();
          }
          if (chapter.rotateAnimation) {
              map.once('moveend', () => {
                  const rotateNumber = map.getBearing();
                  map.rotateTo(rotateNumber + 180, {
                      duration: 30000, easing: function (t) {
                          return t;
                      }
                  });
              });
          }
      })
      .onStepExit(response => {
          var chapter = config.chapters.find(chap => chap.id === response.element.id);
          response.element.classList.remove('active');
          if (chapter.onChapterExit.length > 0) {
              chapter.onChapterExit.forEach(setLayerOpacity);
          }
      });
  });

  //Helper functions for insetmap
  function getInsetBounds() {
              let bounds = map.getBounds();

              let boundsJson = {
                  "type": "FeatureCollection",
                  "features": [{
                      "type": "Feature",
                      "properties": {},
                      "geometry": {
                          "type": "Polygon",
                          "coordinates": [
                              [
                                  [
                                      bounds._sw.lng,
                                      bounds._sw.lat
                                  ],
                                  [
                                      bounds._ne.lng,
                                      bounds._sw.lat
                                  ],
                                  [
                                      bounds._ne.lng,
                                      bounds._ne.lat
                                  ],
                                  [
                                      bounds._sw.lng,
                                      bounds._ne.lat
                                  ],
                                  [
                                      bounds._sw.lng,
                                      bounds._sw.lat
                                  ]
                              ]
                          ]
                      }
                  }]
              }

              if (initLoad) {
                  addInsetLayer(boundsJson);
                  initLoad = false;
              } else {
                  updateInsetLayer(boundsJson);
              }

          }

  function addInsetLayer(bounds) {
      insetMap.addSource('boundsSource', {
          'type': 'geojson',
          'data': bounds
      });

      insetMap.addLayer({
          'id': 'boundsLayer',
          'type': 'fill',
          'source': 'boundsSource', // reference the data source
          'layout': {},
          'paint': {
              'fill-color': '#fff', // blue color fill
              'fill-opacity': 0.2
          }
      });
      // // Add a black outline around the polygon.
      insetMap.addLayer({
          'id': 'outlineLayer',
          'type': 'line',
          'source': 'boundsSource',
          'layout': {},
          'paint': {
              'line-color': '#000',
              'line-width': 1
          }
      });
  }

  function updateInsetLayer(bounds) {
      insetMap.getSource('boundsSource').setData(bounds);
  }



  // setup resize event
  window.addEventListener('resize', scroller.resize);

  </script>

</body>
</html>
